# -*- coding: utf-8 -*-
"""MFO FIX.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14H9PEBL8YubqGm_eWoVAM0eMEH0RqwuJ
"""

import numpy as np
import pandas as pd
import math
import random
import matplotlib.pyplot as plt

from google.colab import files
data_to_load = files.upload()

nasa_93 = pd.read_csv('dataset.csv')

EM = nasa_93["EM"]
LOC = nasa_93["loc"]
A_TD = nasa_93["A_TD"]
A_E = nasa_93["AE"]

nasa = pd.DataFrame(nasa_93, columns=["EM", "loc", "AE", "A_TD"])

def initialize(pop_size, d, ub, lb):
    position = np.random.rand(pop_size, d) * (ub - lb) + lb
    return position

# fitness function
def fitness_function_nasa(nasa, constant):
    a = constant[0]
    b = constant[1]
    c = constant[2]
    d = constant[3]
    total_mre_tdev = 0
    total_mre_effort = 0
    count = 0
    MMRE_TDEV = 0
    MMRE_EFFORT = 0
    tdev_list = []
    effort_list = []

    for row in nasa.itertuples():
        EM = row.EM
        LOC = row.loc
        A_TD = row.A_TD
        AE = row.AE
        PM = a * (LOC) * EM
        TD = c * (PM)
        mre_tdev = (abs(A_TD-TD) / A_TD) * 100
        mre_effort = (abs(AE-PM) / AE) * 100
        tdev_list.append(mre_tdev)
        effort_list.append(mre_effort)
        total_mre_tdev += mre_tdev
        total_mre_effort += mre_effort
        count += 1

    MMRE_TDEV = total_mre_tdev / count
    MMRE_EFFORT = total_mre_effort / count

    return [MMRE_TDEV, MMRE_EFFORT]

def moth_flame_optimization(pop_size, max_t, lb, ub, d):
    best_pos = np.zeros(d)
    best_val = [np.inf, np.inf]

    position = initialize(pop_size, d, ub, lb)
    convergence_curve = np.zeros(max_t)

    t = 0

    while t < max_t:
        for i in range(position.shape[0]):
            check_ub = position[i, :] > ub
            check_lb = position[i, :] < lb
            position[i, :] = (position[i, :] * ~(check_ub + check_lb)) + ub * check_ub + lb * check_lb

            fitness_val = fitness_function_nasa(nasa,position[i, :])
            if sum(fitness_val) < sum(best_val):
                best_val = fitness_val
                best_pos = position[i, :]

            light_intensity = 1 - fitness_val[1]
            flame_intensity = 0.9  # Intensitas nyala api (flame intensity)

            for j in range(position.shape[1]):
                distance_to_light = abs(position[i, j] - best_pos[j])
                attraction_to_light = light_intensity * np.exp(-distance_to_light)
                random_direction = np.random.uniform(low=-1, high=1, size=1)
                movement = attraction_to_light * random_direction

                # Update posisi ngengat
                position[i, j] += movement

                # Memastikan ngengat tetap dalam rentang pencarian (search space)
                position[i, j] = np.clip(position[i, j], lb, ub)

            # Menggunakan nyala api untuk mempengaruhi gerakan ngengat
            random_flame = np.random.uniform(low=0, high=1, size=1)
            if random_flame < flame_intensity:
                distance_to_flame = abs(position[i, :] - best_pos)
                attraction_to_flame = 1 / (1 + distance_to_flame)
                random_direction = np.random.uniform(low=-1, high=1, size=d)
                movement = attraction_to_flame * random_direction

                # Update posisi ngengat
                position[i, :] += movement

                # Memastikan ngengat tetap dalam rentang pencarian (search space)
                position[i, :] = np.clip(position[i, :], lb, ub)

        t += 1
        convergence_curve[t - 1] = min(best_val)

    return best_pos, best_val, convergence_curve

# Parameter algoritma
pop_size = 10
max_t = 5
lb = -5
ub = 10
d = 4

# Menjalankan algoritma Moth Flame Optimization
best_pos, best_val, sol_convergence = moth_flame_optimization(pop_size, max_t, lb, ub, d)

# Print results
print('Best Position (a, b):', best_pos[:2])
print('Best Value (a, b):', best_val[1])
print('Best Position (c, d):', best_pos[2:])
print('Best Value (c, d):', best_val[0])

plt.plot(sol_convergence, color='r')
plt.title('Convergence Curve')
plt.xlabel('Iteration')
plt.ylabel('Best Value')
plt.grid(True)
plt.show()